Suppose an array of lengthnsorted in ascending order isrotatedbetween1andntimes. For example, the arraynums = [0,1,4,4,5,6,7]might become:[4,5,6,7,0,1,4]if it was rotated4times.[0,1,4,4,5,6,7]if it was rotated7times.Notice thatrotatingan array[a[0], a[1], a[2], ..., a[n-1]]1 time results in the array[a[n-1], a[0], a[1], a[2], ..., a[n-2]].Given the sorted rotated arraynumsthat may containduplicates, returnthe minimum element of this array.You must decrease the overall operation steps as much as possible.Example 1:Input:nums = [1,3,5]Output:1Example 2:Input:nums = [2,2,2,0,1]Output:0Constraints:n == nums.length1 <= n <= 5000-5000 <= nums[i] <= 5000numsis sorted and rotated between1andntimes.Follow up:This problem is similar toFind Minimum in Rotated Sorted Array, butnumsmay containduplicates. Would this affect the runtime complexity? How and why?