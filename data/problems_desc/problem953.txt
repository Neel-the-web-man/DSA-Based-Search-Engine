There is a hidden permutationa1,a2,…,ana_1, a_2,\dots, a_na1​,a2​,…,an​of integers1,2,…,n1, 2,\dots, n1,2,…,n. Your task is to sort the permutation by reversing subarrays.On each turn, you can reverse a subarray of the permutation. After that, you will be reported the number of inversions in the permutation. If the number of inversions is000(i.e., the permutation is sorted), you win.InteractionThis is an interactive problem. Your code will interact with the grader using standard input and output. You should start by reading a single integernnn: the length of the permutation.On your turn, print two integersiiiandjjj: reverse the subarray between indicesiiiandjjj.After this, the next input line has a single integer: the number of inversions after the operation. If the number is000, you win and your program must terminate after this.Constraints1≤n≤10001\leq n\leq 10001≤n≤1000you can make at most4n4n4noperationsExample3
1 2
1
2 3
0Explanation: Here the initial permutation is[3,1,2][3,1,2][3,1,2]. After the first operation the permutation is[1,3,2][1,3,2][1,3,2]and the number of inversions is111. After the second operation the permutation is[1,2,3][1,2,3][1,2,3]and the number of inversions is000.