Given an integer arraydatarepresenting the data, return whether it is a validUTF-8encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).A character inUTF8can be from1 to 4 byteslong, subjected to the following rules:For a1-bytecharacter, the first bit is a0, followed by its Unicode code.For ann-bytescharacter, the firstnbits are all one's, then + 1bit is0, followed byn - 1bytes with the most significant2bits being10.This is how the UTF-8 encoding would work:Number of Bytes   |        UTF-8 Octet Sequence
                       |              (binary)
   --------------------+-----------------------------------------
            1          |   0xxxxxxx
            2          |   110xxxxx 10xxxxxx
            3          |   1110xxxx 10xxxxxx 10xxxxxx
            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxxxdenotes a bit in the binary form of a byte that may be either0or1.Note:The input is an array of integers. Only theleast significant 8 bitsof each integer is used to store the data. This means each integer represents only 1 byte of data.Example 1:Input:data = [197,130,1]Output:trueExplanation:data represents the octet sequence: 11000101 10000010 00000001.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.Example 2:Input:data = [235,140,4]Output:falseExplanation:data represented the octet sequence: 11101011 10001100 00000100.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.Constraints:1 <= data.length <= 2 * 1040 <= data[i] <= 255