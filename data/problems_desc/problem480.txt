The hash of a0-indexedstringsof lengthk, given integerspandm, is computed using the following function:hash(s, p, m) = (val(s[0]) * p0+ val(s[1]) * p1+ ... + val(s[k-1]) * pk-1) mod m.Whereval(s[i])represents the index ofs[i]in the alphabet fromval('a') = 1toval('z') = 26.You are given a stringsand the integerspower,modulo,k, andhashValue.Returnsub,thefirstsubstringofsof lengthksuch thathash(sub, power, modulo) == hashValue.The test cases will be generated such that an answer alwaysexists.Asubstringis a contiguous non-empty sequence of characters within a string.Example 1:Input:s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0Output:"ee"Explanation:The hash of "ee" can be computed to be hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. 
"ee" is the first substring of length 2 with hashValue 0. Hence, we return "ee".Example 2:Input:s = "fbxzaad", power = 31, modulo = 100, k = 3, hashValue = 32Output:"fbx"Explanation:The hash of "fbx" can be computed to be hash("fbx", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. 
The hash of "bxz" can be computed to be hash("bxz", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. 
"fbx" is the first substring of length 3 with hashValue 32. Hence, we return "fbx".
Note that "bxz" also has a hash of 32 but it appears later than "fbx".Constraints:1 <= k <= s.length <= 2 * 1041 <= power, modulo <= 1090 <= hashValue < modulosconsists of lowercase English letters only.The test cases are generated such that an answer alwaysexists.