There is an integer arraynumssorted in non-decreasing order (not necessarily withdistinctvalues).Before being passed to your function,numsisrotatedat an unknown pivot indexk(0 <= k < nums.length) such that the resulting array is[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]](0-indexed). For example,[0,1,2,4,4,4,5,6,6,7]might be rotated at pivot index5and become[4,5,6,6,7,0,1,2,4,4].Given the arraynumsafterthe rotation and an integertarget, returntrueiftargetis innums, orfalseif it is not innums.You must decrease the overall operation steps as much as possible.Example 1:Input:nums = [2,5,6,0,0,1,2], target = 0Output:trueExample 2:Input:nums = [2,5,6,0,0,1,2], target = 3Output:falseConstraints:1 <= nums.length <= 5000-104<= nums[i] <= 104numsis guaranteed to be rotated at some pivot.-104<= target <= 104Follow up:This problem is similar toSearch in Rotated Sorted Array, butnumsmay containduplicates. Would this affect the runtime complexity? How and why?